import numpy as np
from queue import PriorityQueue

def heuristic(state,goal):
    return np.count_nonzero(goal!=state)
def moves(state):
    moves = []
    x,y = np.where(state==0)
    for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:
        nx,ny = x+dx,y+dy
        if 0<=nx<3 and 0<=ny<3:
            new = state.copy()
            swap(new[x,y],new[x,y])
            moves.append(new)
    return moves
def solve(initial,goal):
    pq = PriorityQueue()
    count = 0
    pq.put((0,count,initial,None))
    visited = {}
    while not pq.empty():
        _,_,state,parent = pq.get()
        key = str(state)
        if key in visited:
            continue
        visited[key] = parent
        if np.array_equal(state,goal):
            path = []
            curr_str = key
            while curr_str is not None:
                path.append(curr_str)
                curr_str = cisited[curr_str]
            return path[::-1]
        for nxt in moves(state):
            if str(nxt) not in visited:
                count += 1
                priority = heuristic(nxt,goal)
                pq.put((priority,count,nxt,key))
    return count_nonzero
    

sc = StandardScaler()
x_train_std = sc.fit_transform(s_train)
x_test_std = sc.tranform(s_test)

model = LogisticRegression(c =0.1)
model.fit(x_train_std,y_train)
y_pred = model.predict(x_test_std)
accuracy = np.mean(y_pred == y_test)

x_min,x_max = x_train_std[:,0].min()-1,x_train_std[:,0].max()+1
y_min,y_max = x_train_std[:,1].min()-1,x_train_std[:,1].max()+1

xx,yy = np.meshgrid(np.arange(xmin,xmax,0.1),np.arange(y_min,ymax,o.1))
z = model.predict(np.c_[xx.ravel(),yy.ravel()])
z = z.reshape(xx.shape)
plt.contour(xx,yy,z,alpha = 0.4)
plt.scatter(x_train_std[:,0],x_train_std[:,1],c = y_train)













